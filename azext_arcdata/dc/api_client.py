# ------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# ------------------------------------------------------------------------------

# coding: utf-8
"""
    Controller API

    No description provided (generated by Swagger Codegen
    https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: v1.0.0

    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

# from azdata.cli.core.configuration import Configuration
from knack.log import get_logger

from six.moves.urllib.parse import urlencode
from six.moves.urllib.parse import quote
import azext_arcdata.kubernetes_sdk.models

import datetime
import json
import mimetypes
from multiprocessing.pool import ThreadPool
import os
import re
import tempfile
import io
import ssl
import certifi
import importlib

# python 2 and python 3 compatibility library
import six
from six.moves.urllib.parse import quote


try:
    import urllib3
except ImportError:
    raise ImportError("Swagger python client requires urllib3.")

logger = get_logger(__name__)


class ApiClient(object):
    """Generic API client for Swagger client library builds.

    Swagger generic API client. This client handles the client-
    server communication, and is invariant across implementations. Specifics of
    the methods and models for each application are generated from the Swagger
    templates.

    NOTE: This class is auto generated by the swagger code generator program.
    Ref: https://github.com/swagger-api/swagger-codegen
    Do not edit the class manually.

    :param configuration: .Configuration object for this client
    :param header_name: a header to pass when making calls to the API.
    :param header_value: a header value to pass when making calls to
        the API.
    :param cookie: a cookie to include in the header when making calls
        to the API
    """

    PRIMITIVE_TYPES = (float, bool, bytes, six.text_type) + six.integer_types
    NATIVE_TYPES_MAPPING = {
        "int": int,
        "long": int if six.PY3 else long,  # noqa: F821
        "float": float,
        "str": str,
        "bool": bool,
        "date": datetime.date,
        "datetime": datetime.datetime,
        "object": object,
    }

    def __init__(
        self,
        configuration=None,
        header_name=None,
        header_value=None,
        cookie=None,
        model_namespace=None,
    ):
        if configuration is None:
            configuration = ConfigurationOld()
        self.configuration = configuration

        self.rest_client = RESTClientObject(configuration)
        self.default_headers = {}
        if header_name is not None:
            self.default_headers[header_name] = header_value
        self.cookie = cookie

        # Set default User-Agent.
        self.user_agent = self.configuration.user_agent

        self._model_namespace = model_namespace

    def __del__(self):
        pass

    @property
    def user_agent(self):
        """User agent for this API client"""
        return self.default_headers["User-Agent"]

    @user_agent.setter
    def user_agent(self, value):
        self.default_headers["User-Agent"] = value

    @property
    def model_namespace(self):
        return self._model_namespace

    def set_default_header(self, header_name, header_value):
        self.default_headers[header_name] = header_value

    def __call_api(
        self,
        resource_path,
        method,
        path_params=None,
        query_params=None,
        header_params=None,
        body=None,
        post_params=None,
        files=None,
        response_type=None,
        auth_settings=None,
        _return_http_data_only=None,
        collection_formats=None,
        _preload_content=True,
        _request_timeout=None,
    ):

        config = self.configuration

        # header parameters
        header_params = header_params or {}
        header_params.update(self.default_headers)
        if self.cookie:
            header_params["Cookie"] = self.cookie
        if header_params:
            header_params = self.sanitize_for_serialization(header_params)
            header_params = dict(
                self.parameters_to_tuples(header_params, collection_formats)
            )

        # path parameters
        if path_params:
            path_params = self.sanitize_for_serialization(path_params)
            path_params = self.parameters_to_tuples(
                path_params, collection_formats
            )
            for k, v in path_params:
                # specified safe chars, encode everything
                resource_path = resource_path.replace(
                    "{%s}" % k,
                    quote(str(v), safe=config.safe_chars_for_path_param),
                )

        # query parameters
        if query_params:
            query_params = self.sanitize_for_serialization(query_params)
            query_params = self.parameters_to_tuples(
                query_params, collection_formats
            )

        # post parameters
        if post_params or files:
            post_params = self.prepare_post_parameters(post_params, files)
            post_params = self.sanitize_for_serialization(post_params)
            post_params = self.parameters_to_tuples(
                post_params, collection_formats
            )

        # auth setting
        self.update_params_for_auth(header_params, query_params, auth_settings)

        # body
        if body:
            body = self.sanitize_for_serialization(body)

        # request url
        url = self.configuration.host + resource_path

        # perform request and return response
        # TODO: Remove mitigation of default 60 sec. request_timeout once
        #  controller leak is fixed.
        response_data = self.request(
            method,
            url,
            query_params=query_params,
            headers=header_params,
            post_params=post_params,
            body=body,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
            response_type=response_type,
        )

        self.last_response = response_data

        return_data = response_data
        if _preload_content:
            # deserialize response data
            if response_type:
                return_data = self.deserialize(response_data, response_type)
            else:
                return_data = None

        if _return_http_data_only:
            return return_data
        else:
            return (
                return_data,
                response_data.status,
                response_data.getheaders(),
            )

    def sanitize_for_serialization(self, obj):
        """Builds a JSON POST object.

        If obj is None, return None.
        If obj is str, int, long, float, bool, return directly.
        If obj is datetime.datetime, datetime.date
            convert to string in iso8601 format.
        If obj is list, sanitize each element in the list.
        If obj is dict, return the dict.
        If obj is swagger model, return the properties dict.

        :param obj: The data to serialize.
        :return: The serialized form of data.
        """
        if obj is None:
            return None
        elif isinstance(obj, self.PRIMITIVE_TYPES):
            return obj
        elif isinstance(obj, list):
            return [self.sanitize_for_serialization(sub_obj) for sub_obj in obj]
        elif isinstance(obj, tuple):
            return tuple(
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            )
        elif isinstance(obj, (datetime.datetime, datetime.date)):
            return obj.isoformat()

        if isinstance(obj, dict):
            obj_dict = obj
        else:
            # Convert model obj to dict except
            # attributes `swagger_types`, `attribute_map`
            # and attributes which value is not None.
            # Convert attribute name to json key in
            # model definition for request.
            obj_dict = {
                obj.attribute_map[attr]: getattr(obj, attr)
                for attr, _ in six.iteritems(obj.swagger_types)
                if getattr(obj, attr) is not None
            }

        return {
            key: self.sanitize_for_serialization(val)
            for key, val in six.iteritems(obj_dict)
        }

    def deserialize(self, response, response_type):
        """Deserializes response into an object.

        :param response: RESTResponse object to be deserialized.
        :param response_type: class literal for
            deserialized object, or string of class name.

        :return: deserialized object.
        """
        # handle file downloading
        # save response body into a tmp file and return the instance
        if response_type == "file":
            return self.__deserialize_file(response)

        # fetch data from response object
        try:
            data = json.loads(response.data)
        except ValueError:
            data = response.data

        return self.__deserialize(data, response_type)

    def __deserialize(self, data, klass):
        """Deserializes dict, list, str into an object.

        :param data: dict, list or str.
        :param klass: class literal, or string of class name.

        :return: object.
        """
        if data is None:
            return None

        if type(klass) == str:
            if klass.startswith("list["):
                sub_kls = re.match(r"list\[(.*)\]", klass).group(1)
                return [
                    self.__deserialize(sub_data, sub_kls) for sub_data in data
                ]

            if klass.startswith("dict("):
                sub_kls = re.match(r"dict\(([^,]*), (.*)\)", klass).group(2)
                return {
                    k: self.__deserialize(v, sub_kls)
                    for k, v in six.iteritems(data)
                }

            # convert str to class
            if klass in self.NATIVE_TYPES_MAPPING:
                klass = self.NATIVE_TYPES_MAPPING[klass]
            else:
                if hasattr(azdata.cli.core.models, klass):
                    klass = getattr(azdata.cli.core.models, klass)
                else:
                    mod = importlib.import_module(self.model_namespace)
                    klass = getattr(mod, klass)

        if klass in self.PRIMITIVE_TYPES:
            return self.__deserialize_primitive(data, klass)
        elif klass == object:
            return self.__deserialize_object(data)
        elif klass == datetime.date:
            return self.__deserialize_date(data)
        elif klass == datetime.datetime:
            return self.__deserialize_datatime(data)
        else:
            return self.__deserialize_model(data, klass)

    def call_api(
        self,
        resource_path,
        method,
        path_params=None,
        query_params=None,
        header_params=None,
        body=None,
        post_params=None,
        files=None,
        response_type=None,
        auth_settings=None,
        async_req=None,
        _return_http_data_only=None,
        collection_formats=None,
        _preload_content=True,
        _request_timeout=None,
    ):
        """Makes the HTTP request (synchronous) and returns deserialized data.

        To make an async request, set the async_req parameter.

        :param resource_path: Path to method endpoint.
        :param method: Method to call.
        :param path_params: Path parameters in the url.
        :param query_params: Query parameters in the url.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for `application/x-www-form-urlencoded`, `multipart/form-data`.
        :param auth_settings list: Auth Settings names for the request.
        :param response: Response data type.
        :param files dict: key -> filename, value -> filepath,
            for `multipart/form-data`.
        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param collection_formats: dict of collection formats for path, query,
            header, and post parameters.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return:
            If async_req parameter is True,
            the request will be called asynchronously.
            The method will return the request thread.
            If parameter async_req is False or missing,
            then the method will return the response directly.
        """
        if not async_req:
            return self.__call_api(
                resource_path,
                method,
                path_params,
                query_params,
                header_params,
                body,
                post_params,
                files,
                response_type,
                auth_settings,
                _return_http_data_only,
                collection_formats,
                _preload_content,
                _request_timeout,
            )
        else:
            raise ValueError("No async supported")

    def request(
        self,
        method,
        url,
        query_params=None,
        headers=None,
        post_params=None,
        body=None,
        _preload_content=True,
        _request_timeout=None,
        response_type=None,
    ):
        """Makes the HTTP request using RESTClient."""
        if method == "GET":
            return self.rest_client.GET(
                url,
                query_params=query_params,
                _preload_content=_preload_content,
                _request_timeout=_request_timeout,
                headers=headers,
                response_type=response_type,
            )
        elif method == "HEAD":
            return self.rest_client.HEAD(
                url,
                query_params=query_params,
                _preload_content=_preload_content,
                _request_timeout=_request_timeout,
                headers=headers,
                response_type=response_type,
            )
        elif method == "OPTIONS":
            return self.rest_client.OPTIONS(
                url,
                query_params=query_params,
                headers=headers,
                post_params=post_params,
                _preload_content=_preload_content,
                _request_timeout=_request_timeout,
                body=body,
                response_type=response_type,
            )
        elif method == "POST":
            return self.rest_client.POST(
                url,
                query_params=query_params,
                headers=headers,
                post_params=post_params,
                _preload_content=_preload_content,
                _request_timeout=_request_timeout,
                body=body,
                response_type=response_type,
            )
        elif method == "PUT":
            return self.rest_client.PUT(
                url,
                query_params=query_params,
                headers=headers,
                post_params=post_params,
                _preload_content=_preload_content,
                _request_timeout=_request_timeout,
                body=body,
                response_type=response_type,
            )
        elif method == "PATCH":
            return self.rest_client.PATCH(
                url,
                query_params=query_params,
                headers=headers,
                post_params=post_params,
                _preload_content=_preload_content,
                _request_timeout=_request_timeout,
                body=body,
                response_type=response_type,
            )
        elif method == "DELETE":
            return self.rest_client.DELETE(
                url,
                query_params=query_params,
                headers=headers,
                _preload_content=_preload_content,
                _request_timeout=_request_timeout,
                body=body,
                response_type=response_type,
            )
        else:
            raise ValueError(
                "http method must be `GET`, `HEAD`, `OPTIONS`,"
                " `POST`, `PATCH`, `PUT` or `DELETE`."
            )

    def parameters_to_tuples(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: Parameters as list of tuples, collections formatted
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in (
            six.iteritems(params) if isinstance(params, dict) else params
        ):  # noqa: E501
            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == "multi":
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == "ssv":
                        delimiter = " "
                    elif collection_format == "tsv":
                        delimiter = "\t"
                    elif collection_format == "pipes":
                        delimiter = "|"
                    else:  # csv is the default
                        delimiter = ","
                    new_params.append(
                        (k, delimiter.join(str(value) for value in v))
                    )
            else:
                new_params.append((k, v))
        return new_params

    def prepare_post_parameters(self, post_params=None, files=None):
        """Builds form parameters.

        :param post_params: Normal form parameters.
        :param files: File parameters.
        :return: Form parameters with files.
        """
        params = []

        if post_params:
            params = post_params

        if files:
            for k, v in six.iteritems(files):
                if not v:
                    continue
                file_names = v if type(v) is list else [v]
                for n in file_names:
                    with open(n, "rb") as f:
                        filename = os.path.basename(f.name)
                        filedata = f.read()
                        mimetype = (
                            mimetypes.guess_type(filename)[0]
                            or "application/octet-stream"
                        )
                        params.append(
                            tuple([k, tuple([filename, filedata, mimetype])])
                        )

        return params

    def select_header_accept(self, accepts):
        """Returns `Accept` based on an array of accepts provided.

        :param accepts: List of headers.
        :return: Accept (e.g. application/json).
        """
        if not accepts:
            return

        accepts = [x.lower() for x in accepts]

        if "application/json" in accepts:
            return "application/json"
        else:
            return ", ".join(accepts)

    def select_header_content_type(self, content_types):
        """Returns `Content-Type` based on an array of content_types provided.

        :param content_types: List of content-types.
        :return: Content-Type (e.g. application/json).
        """
        if not content_types:
            return "application/json"

        content_types = [x.lower() for x in content_types]

        if "application/json" in content_types or "*/*" in content_types:
            return "application/json"
        else:
            return content_types[0]

    def update_params_for_auth(self, headers, querys, auth_settings):
        """Updates header and query params based on authentication setting.

        :param headers: Header parameters dict to be updated.
        :param querys: Query parameters tuple list to be updated.
        :param auth_settings: Authentication setting identifiers list.
        """
        if not auth_settings:
            return

        for auth in auth_settings:
            auth_setting = self.configuration.auth_settings().get(auth)
            if auth_setting:
                if not auth_setting["value"]:
                    continue
                elif auth_setting["in"] == "header":
                    headers[auth_setting["key"]] = auth_setting["value"]
                elif auth_setting["in"] == "query":
                    querys.append((auth_setting["key"], auth_setting["value"]))
                else:
                    raise ValueError(
                        "Authentication token must be in `query` or `header`"
                    )

    def __deserialize_file(self, response):
        """Deserializes body to file

        Saves response body into a file in a temporary folder,
        using the filename from the `Content-Disposition` header if provided.

        :param response:  RESTResponse.
        :return: file path.
        """
        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
        os.close(fd)
        os.remove(path)

        content_disposition = response.getheader("Content-Disposition")
        if content_disposition:
            filename = re.search(
                r'filename=[\'"]?([^\'"\s]+)[\'"]?', content_disposition
            ).group(1)
            path = os.path.join(os.path.dirname(path), filename)

        with open(path, "wb") as f:
            f.write(response.data)

        return path

    def __deserialize_primitive(self, data, klass):
        """Deserializes string to primitive type.

        :param data: str.
        :param klass: class literal.

        :return: int, long, float, str, bool.
        """
        try:
            return klass(data)
        except UnicodeEncodeError:
            return six.text_type(data)
        except TypeError:
            return data

    def __deserialize_object(self, value):
        """Return a original value.

        :return: object.
        """
        return value

    def __deserialize_date(self, string):
        """Deserializes string to date.

        :param string: str.
        :return: date.
        """
        try:
            from dateutil.parser import parse

            return parse(string).date()
        except ImportError:
            return string
        except ValueError:
            raise ApiError(
                status=0,
                reason="Failed to parse `{0}` as date object".format(string),
            )

    def __deserialize_datatime(self, string):
        """Deserializes string to datetime.

        The string should be in iso8601 datetime format.

        :param string: str.
        :return: datetime.
        """
        try:
            from dateutil.parser import parse

            return parse(string)
        except ImportError:
            return string
        except ValueError:
            raise ApiError(
                status=0,
                reason=(
                    "Failed to parse `{0}` as datetime object".format(string)
                ),
            )

    def __hasattr(self, object, name):
        return name in object.__class__.__dict__

    def __deserialize_model(self, data, klass):
        """Deserializes list or dict to model.

        :param data: dict, list.
        :param klass: class literal.
        :return: model object.
        """

        if not klass.swagger_types and not self.__hasattr(
            klass, "get_real_child_model"
        ):
            return data

        kwargs = {}
        if klass.swagger_types is not None:
            for attr, attr_type in six.iteritems(klass.swagger_types):
                if (
                    data is not None
                    and klass.attribute_map[attr] in data
                    and isinstance(data, (list, dict))
                ):
                    value = data[klass.attribute_map[attr]]
                    kwargs[attr] = self.__deserialize(value, attr_type)

        instance = klass(**kwargs)

        if (
            isinstance(instance, dict)
            and klass.swagger_types is not None
            and isinstance(data, dict)
        ):
            for key, value in data.items():
                if key not in klass.swagger_types:
                    instance[key] = value
        if self.__hasattr(instance, "get_real_child_model"):
            klass_name = instance.get_real_child_model(data)
            if klass_name:
                instance = self.__deserialize(data, klass_name)
        return instance


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------


# coding: utf-8

"""
    Controller API

    No description provided (generated by Swagger Codegen
    https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: v1.0.0

    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


class RESTResponse(io.IOBase):
    def __init__(self, resp):
        self.urllib3_response = resp
        self.status = resp.status
        self.reason = resp.reason
        self.data = resp.data

    def getheaders(self):
        """Returns a dictionary of the response headers."""
        return self.urllib3_response.getheaders()

    def getheader(self, name, default=None):
        """Returns a given response header."""
        return self.urllib3_response.getheader(name, default)


class RESTClientObject(object):
    class RESTClientLogSanitizer(object):
        def __init__(self, url):
            def fn(url, log_api_blacklist):
                def _suppress(ctx, payload):
                    log_payload = payload
                    for suppress_logging in log_api_blacklist[ctx]:
                        if suppress_logging.match(url):
                            log_payload = "<PRIVATE>"
                            break
                    return log_payload

                return _suppress

            self._url = url
            self._log_api_blacklist = []  # Configuration().log_api_blacklist
            self._suppress_payload = fn(self._url, self._log_api_blacklist)

        def url(self):
            """Log request url."""
            logger.debug("request url: %s", self._url)

        def method(self, method):
            """Log request method."""
            logger.debug("request method: %s", method)

        def headers(self, headers):
            """
            Log request headers skipping any urls that contain private
            information.
            """
            log_headers = headers.copy()
            for suppress_logging in self._log_api_blacklist["headers"]:
                if suppress_logging["url"].match(self._url):
                    # suppress specific header logging from this url
                    for h in log_headers:
                        if h in suppress_logging["values"]:
                            log_headers[h] = "<PRIVATE>"
            for h in log_headers:
                logger.debug("request header[%s]: %s", h, log_headers[h])

        def request(self, request):
            """
            Log request body skipping any urls that contain private information.
            """
            logger.debug(
                "request payload: %s",
                self._suppress_payload("request", request),
            )

        def response(self, response):
            """
            Log response body skipping any urls that contain private
            information.
            """
            logger.debug(
                "response payload: %s",
                self._suppress_payload("response", response),
            )

    def __init__(self, configuration, pools_size=4, maxsize=None):
        # urllib3.PoolManager will pass all kw parameters to connectionpool
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
        # maxsize is the number of requests to host that are allowed in parallel  # noqa: E501
        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501

        # cert_reqs
        if configuration.verify_ssl:
            cert_reqs = ssl.CERT_REQUIRED
        else:
            cert_reqs = ssl.CERT_NONE

        # ca_certs
        if configuration.ssl_ca_cert:
            ca_certs = configuration.ssl_ca_cert
        else:
            # if not set certificate file, use Mozilla's root certificates.
            ca_certs = certifi.where()

        addition_pool_args = {}
        if configuration.assert_hostname is not None:
            addition_pool_args[
                "assert_hostname"
            ] = configuration.assert_hostname  # noqa: E501

        if maxsize is None:
            if configuration.connection_pool_maxsize is not None:
                maxsize = configuration.connection_pool_maxsize
            else:
                maxsize = 4

        # https pool manager
        if configuration.proxy:
            self.pool_manager = urllib3.ProxyManager(
                num_pools=pools_size,
                maxsize=maxsize,
                cert_reqs=cert_reqs,
                ca_certs=ca_certs,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                proxy_url=configuration.proxy,
                **addition_pool_args,
            )
        else:
            self.pool_manager = urllib3.PoolManager(
                num_pools=pools_size,
                maxsize=maxsize,
                cert_reqs=cert_reqs,
                ca_certs=ca_certs,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                **addition_pool_args,
            )

    def request(
        self,
        method,
        url,
        query_params=None,
        headers=None,
        body=None,
        post_params=None,
        _preload_content=True,
        _request_timeout=None,
        response_type=None,
    ):
        """Perform requests.

        :param method: http request method
        :param url: http request url
        :param query_params: query parameters in the url
        :param headers: http request headers
        :param body: request json body, for `application/json`
        :param post_params: request post parameters,
                            `application/x-www-form-urlencoded`
                            and `multipart/form-data`
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        """
        method = method.upper()
        assert method in [
            "GET",
            "HEAD",
            "DELETE",
            "POST",
            "PUT",
            "PATCH",
            "OPTIONS",
        ]

        if post_params and body:
            raise ValueError(
                "body parameter cannot be used with post_params parameter."
            )

        post_params = post_params or {}
        headers = headers or {}

        timeout = None
        if _request_timeout:
            if isinstance(
                _request_timeout, (int,) if six.PY3 else (int, long)
            ):  # noqa: E501,F821
                timeout = urllib3.Timeout(total=_request_timeout)
            elif (
                isinstance(_request_timeout, tuple)
                and len(_request_timeout) == 2
            ):
                timeout = urllib3.Timeout(
                    connect=_request_timeout[0], read=_request_timeout[1]
                )

        if "Content-Type" not in headers:
            headers["Content-Type"] = "application/json"

        try:
            log = self.RESTClientLogSanitizer(url)
            log.url()
            log.method(method)
            log.headers(headers)

            # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
            if method in ["POST", "PUT", "PATCH", "OPTIONS", "DELETE"]:
                if query_params:
                    url += "?" + urlencode(query_params)
                if re.search("json", headers["Content-Type"], re.IGNORECASE):
                    request_body = None
                    if body is not None:
                        request_body = json.dumps(body)

                    log.request(request_body)

                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        preload_content=_preload_content,
                        timeout=timeout,
                        headers=headers,
                    )
                elif (
                    headers["Content-Type"]
                    == "application/x-www-form-urlencoded"
                ):
                    log.request(post_params)

                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=False,
                        preload_content=_preload_content,
                        timeout=timeout,
                        headers=headers,
                    )
                elif headers["Content-Type"] == "multipart/form-data":
                    # must del headers['Content-Type'], or the correct
                    # Content-Type which generated by urllib3 will be
                    # overwritten.
                    del headers["Content-Type"]
                    log.request("multipart/form-data")

                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=True,
                        preload_content=_preload_content,
                        timeout=timeout,
                        headers=headers,
                    )
                # Pass a `string` parameter directly in the body to support
                # other content types than Json when `body` argument is
                # provided in serialized form
                elif isinstance(body, str):
                    request_body = body
                    log.request(request_body)

                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        preload_content=_preload_content,
                        timeout=timeout,
                        headers=headers,
                    )
                else:
                    # Cannot generate the request from given parameters
                    msg = """Cannot prepare a request message for provided
                             arguments. Please check that your arguments match
                             declared content type."""
                    raise ApiError(status=0, reason=msg)
            # For `GET`, `HEAD`
            else:
                log.request(query_params)

                r = self.pool_manager.request(
                    method,
                    url,
                    fields=query_params,
                    preload_content=_preload_content,
                    timeout=timeout,
                    headers=headers,
                )
        except urllib3.exceptions.SSLError as e:
            msg = "{0}\n{1}".format(type(e).__name__, str(e))
            raise ApiError(status=0, reason=msg)
        except urllib3.exceptions.MaxRetryError as e:
            msg = "{0}\n{1}".format(type(e).__name__, str(e))
            raise ApiError(status=60, reason=msg)

        if _preload_content:
            r = RESTResponse(r)

            # In the python 3, the response.data is bytes.
            # we need to decode it to string.
            if six.PY3 and response_type != "file":
                r.data = r.data.decode("utf8")

            log.response(r.data)

        if r.status == 401:
            raise ApiError(
                status=r.status, reason="Login invalid or expired.", http_resp=r
            )
        if r.status == 403:
            raise ApiError(
                status=r.status, reason="Permission denied.", http_resp=r
            )
        if not 200 <= r.status <= 299:
            raise ApiError(http_resp=r)

        return r

    def GET(
        self,
        url,
        headers=None,
        query_params=None,
        _preload_content=True,
        _request_timeout=None,
        response_type=None,
    ):
        return self.request(
            "GET",
            url,
            headers=headers,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
            query_params=query_params,
            response_type=response_type,
        )

    def HEAD(
        self,
        url,
        headers=None,
        query_params=None,
        _preload_content=True,
        _request_timeout=None,
        response_type=None,
    ):
        return self.request(
            "HEAD",
            url,
            headers=headers,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
            query_params=query_params,
            response_type=response_type,
        )

    def OPTIONS(
        self,
        url,
        headers=None,
        query_params=None,
        post_params=None,
        body=None,
        _preload_content=True,
        _request_timeout=None,
        response_type=None,
    ):
        return self.request(
            "OPTIONS",
            url,
            headers=headers,
            query_params=query_params,
            post_params=post_params,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
            body=body,
            response_type=response_type,
        )

    def DELETE(
        self,
        url,
        headers=None,
        query_params=None,
        body=None,
        _preload_content=True,
        _request_timeout=None,
        response_type=None,
    ):
        return self.request(
            "DELETE",
            url,
            headers=headers,
            query_params=query_params,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
            body=body,
            response_type=response_type,
        )

    def POST(
        self,
        url,
        headers=None,
        query_params=None,
        post_params=None,
        body=None,
        _preload_content=True,
        _request_timeout=None,
        response_type=None,
    ):
        return self.request(
            "POST",
            url,
            headers=headers,
            query_params=query_params,
            post_params=post_params,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
            body=body,
            response_type=response_type,
        )

    def PUT(
        self,
        url,
        headers=None,
        query_params=None,
        post_params=None,
        body=None,
        _preload_content=True,
        _request_timeout=None,
        response_type=None,
    ):
        return self.request(
            "PUT",
            url,
            headers=headers,
            query_params=query_params,
            post_params=post_params,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
            body=body,
            response_type=response_type,
        )

    def PATCH(
        self,
        url,
        headers=None,
        query_params=None,
        post_params=None,
        body=None,
        _preload_content=True,
        _request_timeout=None,
        response_type=None,
    ):
        return self.request(
            "PATCH",
            url,
            headers=headers,
            query_params=query_params,
            post_params=post_params,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
            body=body,
            response_type=response_type,
        )


from knack.cli import CLIError


class ApiError(CLIError):
    """HTTP errors while calling APIs against server controller-plane."""

    def __init__(self, status=None, reason=None, http_resp=None):
        import json

        self.response_json = None

        if http_resp:
            status = http_resp.status
            reason = http_resp.reason
            self.headers = http_resp.getheaders()

            try:
                # HTTP errors can have this json structure in the body.
                # Here we clean it up for exception printing.
                body = json.loads(http_resp.data)
                self.response_json = body
                self.body = ""

                if "Link" in body:
                    self.body = "   Link: " + body["Link"]

                if "Message" in body:
                    self.body += "\n   Message: " + body["Message"]

                if "ExceptionType" in body:
                    self.body += "\n   Exception Type: " + body["ExceptionType"]

                if not self.body:
                    self.body = http_resp.data

            except (IOError, Exception):
                self.body = http_resp.data
        else:
            self.body = None
            self.headers = None

        super(ApiError, self).__init__(reason, status)

    def __str__(self):
        """
        Custom error messages for HTTP exception.
        """
        error_message = "({0})\n" "Reason: {1}\n".format(
            self.status, self.reason
        )
        if self.headers:
            error_message += "HTTP response headers: {0}\n".format(self.headers)

        if self.body:
            error_message += "HTTP response body: {0}\n".format(self.body)

        return error_message


from typing import Iterable


class ControllerError(CLIError):
    """All errors related to Controller APIS."""

    def __init__(self, reason, status, response_json=None):
        if response_json:
            self.detail_list = response_json.get("details", None)
            self.reason_string = response_json.get("reason", "")
            self.help_link = response_json.get("help", "")
        else:
            self.reason_string = reason
        CliError.__init__(self, reason, status)

    def __str__(self):
        """
        Custom error messages for Controller exception.
        """
        detail_message = ""
        help_link_message = ""
        if hasattr(self, "detail_list") and isinstance(
            self.detail_list, Iterable
        ):
            detail_message = (
                "Details: \n\t" + "\n\t".join(self.detail_list) + "\n"
            )
        if hasattr(self, "help_link"):
            help_link_message = (
                "For more help, go to this link: " + self.help_link + "\n"
            )
        error_message = (
            "ERROR: {0}\n"
            "{1}"
            "{2}".format(self.reason_string, detail_message, help_link_message)
        )
        return error_message


####################
####################
####################

# coding: utf-8

"""
    Microsoft SQL Server Controller Service

    No description provided (generated by Swagger Codegen
    https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: v1.0.0

    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

# from azdata.cli.core.clients.api_client import ApiClient


class ClusterRouterApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_cluster(
        self, x_request_id, connection, data, **kwargs
    ):  # noqa: E501
        """Create a cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bdc(x_request_id, connection, data,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str data: Cluster configuration in JSON format (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.create_cluster_with_http_info(
                x_request_id, connection, data, **kwargs
            )  # noqa: E501
        else:
            (data) = self.create_cluster_with_http_info(
                x_request_id, connection, data, **kwargs
            )  # noqa: E501
            return data

    def create_cluster_with_http_info(
        self, x_request_id, connection, data, **kwargs
    ):  # noqa: E501
        """Create a cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_with_http_info(x_request_id,
        connection, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str data: Cluster configuration in JSON format (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["x_request_id", "connection", "data"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cluster" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`create_cluster`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`create_cluster`"
            )  # noqa: E501
        # verify the required parameter 'data' is set
        if "data" not in params or params["data"] is None:
            raise ValueError(
                "Missing the required parameter `data` when calling "
                "`create_cluster`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if "data" in params:
            body_params = params["data"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(
            # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/bdc",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def create_mount(
        self, x_request_id, connection, remote, mount, **kwargs
    ):  # noqa: E501
        """Create a mount  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_mount(x_request_id, connection, remote,
        mount, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str remote: URI of remote store to mount (required)
        :param str mount: Local path to mount on (required)
        :param object credentials: Credentials to create the mount
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.create_mount_with_http_info(
                x_request_id, connection, remote, mount, **kwargs
            )  # noqa: E501
        else:
            (data) = self.create_mount_with_http_info(
                x_request_id, connection, remote, mount, **kwargs
            )  # noqa: E501
            return data

    def create_mount_with_http_info(
        self, x_request_id, connection, remote, mount, **kwargs
    ):  # noqa: E501
        """Create a mount  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_mount_with_http_info(x_request_id,
        connection, remote, mount, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str remote: URI of remote store to mount (required)
        :param str mount: Local path to mount on (required)
        :param object credentials: Credentials to create the mount
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "x_request_id",
            "connection",
            "remote",
            "mount",
            "credentials",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_mount" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`create_mount`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`create_mount`"
            )  # noqa: E501
        # verify the required parameter 'remote' is set
        if "remote" not in params or params["remote"] is None:
            raise ValueError(
                "Missing the required parameter `remote` when calling "
                "`create_mount`"
            )  # noqa: E501
        # verify the required parameter 'mount' is set
        if "mount" not in params or params["mount"] is None:
            raise ValueError(
                "Missing the required parameter `mount` when calling "
                "`create_mount`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if "remote" in params:
            query_params.append(("remote", params["remote"]))  # noqa: E501
        if "mount" in params:
            query_params.append(("mount", params["mount"]))  # noqa: E501

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if "credentials" in params:
            body_params = params["credentials"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(
            # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/bdc/services/hdfs/mounts",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def delete_cluster(self, x_request_id, connection, **kwargs):  # noqa: E501
        """Delete a cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_bdc(x_request_id, connection,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.delete_cluster_with_http_info(
                x_request_id, connection, **kwargs
            )  # noqa: E501
        else:
            (data) = self.delete_cluster_with_http_info(
                x_request_id, connection, **kwargs
            )  # noqa: E501
            return data

    def delete_cluster_with_http_info(
        self, x_request_id, connection, **kwargs
    ):  # noqa: E501
        """Delete a cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cluster_with_http_info(x_request_id,
        connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["x_request_id", "connection"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cluster" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`delete_cluster`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`delete_cluster`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/bdc",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def upgrade_control_plane(
        self, x_request_id, connection, data, **kwargs
    ):  # noqa: E501
        """Upgrade a control plane  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upgrade_control_plane(x_request_id, connection, data,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str data: Cluster patch in JSON format (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.upgrade_control_plane_with_http_info(
                x_request_id, connection, data, data, **kwargs
            )  #
            # noqa: E501
        else:
            (data) = self.upgrade_control_plane_with_http_info(
                x_request_id, connection, data, **kwargs
            )  #
            # noqa: E501
            return data

    def upgrade_control_plane_with_http_info(
        self, x_request_id, connection, data, **kwargs
    ):  # noqa: E501
        """Upgrade a cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upgrade_control_plane_with_http_info(x_request_id,
        connection, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str data: Cluster patch in JSON format (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["x_request_id", "connection", "data"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upgrade_control_plane" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`upgrade_control_plane`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`upgrade_control_plane`"
            )  # noqa: E501

        # verify the required parameter 'data' is set
        if "data" not in params or params["data"] is None:
            raise ValueError(
                "Missing the required parameter `data` when calling "
                "`upgrade_control_plane`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if "data" in params:
            body_params = params["data"]

        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(
            # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/control",
            "PATCH",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def upgrade_bdc(
        self, x_request_id, connection, data, **kwargs
    ):  # noqa: E501
        """Upgrade a Big Data Cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upgrade_bdc(x_request_id, connection, data,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str data: Cluster patch in JSON format (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.upgrade_bdc_with_http_info(
                x_request_id, connection, data, data, **kwargs
            )  # noqa: E501
        else:
            (data) = self.upgrade_bdc_with_http_info(
                x_request_id, connection, data, **kwargs
            )  # noqa: E501
            return data

    def upgrade_bdc_with_http_info(
        self, x_request_id, connection, data, **kwargs
    ):  # noqa: E501
        """Upgrade a cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upgrade_bdc_with_http_info(x_request_id,
        connection, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str data: Cluster patch in JSON format (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["x_request_id", "connection", "data"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upgrade_bdc" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`upgrade_bdc`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`upgrade_bdc`"
            )  # noqa: E501

        # verify the required parameter 'data' is set
        if "data" not in params or params["data"] is None:
            raise ValueError(
                "Missing the required parameter `data` when calling "
                "`upgrade_bdc`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if "data" in params:
            body_params = params["data"]

        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(
            # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/bdc",
            "PATCH",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def delete_mount(
        self, x_request_id, connection, mount, **kwargs
    ):  # noqa: E501
        """Delete a mount  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_mount(x_request_id, connection, mount,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str mount: Local mount path (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.delete_mount_with_http_info(
                x_request_id, connection, mount, **kwargs
            )  # noqa: E501
        else:
            (data) = self.delete_mount_with_http_info(
                x_request_id, connection, mount, **kwargs
            )  # noqa: E501
            return data

    def delete_mount_with_http_info(
        self, x_request_id, connection, mount, **kwargs
    ):  # noqa: E501
        """Delete a mount  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_mount_with_http_info(x_request_id,
        connection, mount, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str mount: Local mount path (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["x_request_id", "connection", "mount"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_mount" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`delete_mount`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`delete_mount`"
            )  # noqa: E501
        # verify the required parameter 'mount' is set
        if "mount" not in params or params["mount"] is None:
            raise ValueError(
                "Missing the required parameter `mount` when calling "
                "`delete_mount`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if "mount" in params:
            query_params.append(("mount", params["mount"]))  # noqa: E501

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(
            # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/bdc/services/hdfs/mounts",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_cluster(self, x_request_id, connection, **kwargs):  # noqa: E501
        """Get cluster config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster(x_request_id, connection,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_cluster_with_http_info(
                x_request_id, connection, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_cluster_with_http_info(
                x_request_id, connection, **kwargs
            )  # noqa: E501
            return data

    def get_cluster_with_http_info(
        self, x_request_id, connection, **kwargs
    ):  # noqa: E501
        """Get cluster config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_with_http_info(x_request_id, connection,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["x_request_id", "connection"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`get_cluster`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`get_cluster`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/bdc",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def endpoints_by_name_get(self, endpoint_name, **kwargs):  # noqa: E501
        """endpoints_by_name_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_by_name_get(endpoint_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str endpoint_name: (required)
        :return: EndpointModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.endpoints_by_name_get_with_http_info(
                endpoint_name, **kwargs
            )  #
            # noqa: E501
        else:
            (data) = self.endpoints_by_name_get_with_http_info(
                endpoint_name, **kwargs
            )  #
            # noqa: E501
            return data

    def endpoints_by_name_get_with_http_info(
        self, endpoint_name, **kwargs
    ):  # noqa: E501
        """endpoints_by_name_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_by_name_get_with_http_info(endpoint_name,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str endpoint_name: (required)
        :return: EndpointModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["endpoint_name"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method endpoints_by_name_get" % key
                )
            params[key] = val
        del params["kwargs"]

        # verify the required parameter 'endpoint_name' is set
        if "endpoint_name" not in params or params["endpoint_name"] is None:
            raise ValueError(
                "Missing the required parameter `endpoint_name` when calling "
                "`endpoints_by_name_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        if "endpoint_name" in params:
            path_params["endpointName"] = params["endpoint_name"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/bdc/endpoints/{endpointName}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def endpoints_get(self, **kwargs):  # noqa: E501
        """endpoints_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[EndpointModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.endpoints_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.endpoints_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def endpoints_get_with_http_info(self, **kwargs):  # noqa: E501
        """endpoints_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[EndpointModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method endpoints_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/bdc/endpoints",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_bdc_resource_status(
        self, x_request_id, connection, resource_name, **kwargs
    ):  # noqa: E501
        """Get BDC status of services that contain this resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bdc_resource_status(x_request_id, connection,
        resource_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str resource_name: (required)
        :param bool all:
        :return: BdcStatusModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_bdc_resource_status_with_http_info(
                x_request_id, connection, resource_name, **kwargs
            )  #
            # noqa: E501
        else:
            (data) = self.get_bdc_resource_status_with_http_info(
                x_request_id, connection, resource_name, **kwargs
            )  #
            #  noqa: E501
            return data

    def get_bdc_resource_status_with_http_info(
        self, x_request_id, connection, resource_name, **kwargs
    ):  # noqa: E501
        """Get BDC status of services that contain this resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bdc_resource_status_with_http_info(x_request_id,
        connection, resource_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str resource_name: (required)
        :param bool all:
        :return: BdcStatusModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "x_request_id",
            "connection",
            "resource_name",
            "all",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bdc_resource_status" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`get_bdc_resource_status`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`get_bdc_resource_status`"
            )  # noqa: E501
        # verify the required parameter 'resource_name' is set
        if "resource_name" not in params or params["resource_name"] is None:
            raise ValueError(
                "Missing the required parameter `resource_name` when calling "
                "`get_bdc_resource_status`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "resource_name" in params:
            path_params["resourceName"] = params["resource_name"]  # noqa: E501

        query_params = []
        if "all" in params:
            query_params.append(("all", params["all"]))  # noqa: E501

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/bdc/resources/{resourceName}/status",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_bdc_service_resource_status(
        self, x_request_id, connection, service_name, resource_name, **kwargs
    ):  # noqa: E501
        """Get resource status within this service  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bdc_service_resource_status(x_request_id,
        connection, service_name, resource_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str service_name: (required)
        :param str resource_name: (required)
        :param bool all:
        :return: ResourceStatusModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_bdc_service_resource_status_with_http_info(
                x_request_id, connection, service_name, resource_name, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_bdc_service_resource_status_with_http_info(
                x_request_id, connection, service_name, resource_name, **kwargs
            )  # noqa: E501
            return data

    def get_bdc_service_resource_status_with_http_info(
        self, x_request_id, connection, service_name, resource_name, **kwargs
    ):  # noqa: E501
        """Get resource status within this service  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bdc_service_resource_status_with_http_info(
        x_request_id, connection, service_name, resource_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str service_name: (required)
        :param str resource_name: (required)
        :param bool all:
        :return: ResourceStatusModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "x_request_id",
            "connection",
            "service_name",
            "resource_name",
            "all",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bdc_service_resource_status" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`get_bdc_service_resource_status`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`get_bdc_service_resource_status`"
            )  # noqa: E501
        # verify the required parameter 'service_name' is set
        if "service_name" not in params or params["service_name"] is None:
            raise ValueError(
                "Missing the required parameter `service_name` when calling "
                "`get_bdc_service_resource_status`"
            )  # noqa: E501
        # verify the required parameter 'resource_name' is set
        if "resource_name" not in params or params["resource_name"] is None:
            raise ValueError(
                "Missing the required parameter `resource_name` when calling "
                "`get_bdc_service_resource_status`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "service_name" in params:
            path_params["serviceName"] = params["service_name"]  # noqa: E501
        if "resource_name" in params:
            path_params["resourceName"] = params["resource_name"]  # noqa: E501

        query_params = []
        if "all" in params:
            query_params.append(("all", params["all"]))  # noqa: E501

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/bdc/services/{serviceName}/resources/{"
            "resourceName}/status",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_bdc_service_status(
        self, x_request_id, connection, service_name, **kwargs
    ):  # noqa: E501
        """Get service status within this BDC  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bdc_service_status(x_request_id, connection,
        service_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str service_name: (required)
        :param bool all:
        :return: ServiceStatusModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_bdc_service_status_with_http_info(
                x_request_id, connection, service_name, **kwargs
            )  #
            # noqa: E501
        else:
            (data) = self.get_bdc_service_status_with_http_info(
                x_request_id, connection, service_name, **kwargs
            )  #
            # noqa: E501
            return data

    def get_bdc_service_status_with_http_info(
        self, x_request_id, connection, service_name, **kwargs
    ):  # noqa: E501
        """Get service status within this BDC  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bdc_service_status_with_http_info(x_request_id,
        connection, service_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str service_name: (required)
        :param bool all:
        :return: ServiceStatusModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "x_request_id",
            "connection",
            "service_name",
            "all",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bdc_service_status" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`get_bdc_service_status`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`get_bdc_service_status`"
            )  # noqa: E501
        # verify the required parameter 'service_name' is set
        if "service_name" not in params or params["service_name"] is None:
            raise ValueError(
                "Missing the required parameter `service_name` when calling "
                "`get_bdc_service_status`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "service_name" in params:
            path_params["serviceName"] = params["service_name"]  # noqa: E501

        query_params = []
        if "all" in params:
            query_params.append(("all", params["all"]))  # noqa: E501

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/bdc/services/{serviceName}/status",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_bdc_status(self, x_request_id, connection, **kwargs):  # noqa: E501
        """Get BDC status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bdc_status(x_request_id, connection,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param bool all:
        :return: BdcStatusModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_bdc_status_with_http_info(
                x_request_id, connection, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_bdc_status_with_http_info(
                x_request_id, connection, **kwargs
            )  # noqa: E501
            return data

    def get_bdc_status_with_http_info(
        self, x_request_id, connection, **kwargs
    ):  # noqa: E501
        """Get BDC status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bdc_status_with_http_info(x_request_id,
        connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param bool all:
        :return: BdcStatusModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["x_request_id", "connection", "all"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bdc_status" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`get_bdc_status`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`get_bdc_status`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if "all" in params:
            query_params.append(("all", params["all"]))  # noqa: E501

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/bdc/status",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=object,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_control_status(
        self, x_request_id, connection, **kwargs
    ):  # noqa: E501
        """Get control status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_control_status(x_request_id, connection,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param bool all: Whether you want all of the instances within the
        resources
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_control_status_with_http_info(
                x_request_id, connection, **kwargs
            )  # noqa:
            # E501
        else:
            (data) = self.get_control_status_with_http_info(
                x_request_id, connection, **kwargs
            )  #
            # noqa: E501
            return data

    def get_control_status_with_http_info(
        self, x_request_id, connection, **kwargs
    ):  # noqa: E501
        """Get control status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_control_status_with_http_info(x_request_id,
        connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param bool all: Whether you want all of the instances within the
        resources
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["x_request_id", "connection", "all"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_control_status" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`get_control_status`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`get_control_status`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if "all" in params:
            query_params.append(("all", params["all"]))  # noqa: E501

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/control/status",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_control_resource_status(
        self, resource_name, **kwargs
    ):  # noqa: E501
        """Get Control status of this resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_control_resource_status(resource_name,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str resource_name: The name of the resource you want the
        status of (required)
        :param str x_request_id:
        :param str connection:
        :param bool all: Whether you want all of the instances within the
        given resource
        :return: ResourceStatusModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_control_resource_status_with_http_info(
                resource_name, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_control_resource_status_with_http_info(
                resource_name, **kwargs
            )  # noqa: E501
            return data

    def get_control_resource_status_with_http_info(
        self, resource_name, **kwargs
    ):  # noqa: E501
        """Get Control status of this resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_control_resource_status_with_http_info(
        resource_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str resource_name: The name of the resource you want the
        status of (required)
        :param str x_request_id:
        :param str connection:
        :param bool all: Whether you want all of the instances within the
        given resource
        :return: ResourceStatusModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "resource_name",
            "x_request_id",
            "connection",
            "all",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_control_resource_status" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'resource_name' is set
        if "resource_name" not in params or params["resource_name"] is None:
            raise ValueError(
                "Missing the required parameter `resource_name` when calling "
                "`get_control_resource_status`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "resource_name" in params:
            path_params["resourceName"] = params["resource_name"]  # noqa: E501

        query_params = []
        if "all" in params:
            query_params.append(("all", params["all"]))  # noqa: E501

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/control/resources/{resourceName}/status",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_health_properties(
        self, x_request_id, connection, query, **kwargs
    ):  # noqa: E501
        """Get health properties with specific query  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_health_properties(x_request_id, connection,
        query, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str query: The query in the json format for the health
        properties (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_health_properties_with_http_info(
                x_request_id, connection, query, **kwargs
            )  #
            # noqa: E501
        else:
            (data) = self.get_health_properties_with_http_info(
                x_request_id, connection, query, **kwargs
            )  #
            # noqa: E501
            return data

    def get_health_properties_with_http_info(
        self, x_request_id, connection, query, **kwargs
    ):  # noqa: E501
        """Get health properties with specific query  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_health_properties_with_http_info(x_request_id,
        connection, query, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str query: The query in the json format for the health
        properties (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["x_request_id", "connection", "query"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_health_properties" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`get_health_properties`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`get_health_properties`"
            )  # noqa: E501
        # verify the required parameter 'query' is set
        if "query" not in params or params["query"] is None:
            raise ValueError(
                "Missing the required parameter `query` when calling "
                "`get_health_properties`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if "query" in params:
            query_params.append(("query", params["query"]))  # noqa: E501

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(
            # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/health",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_home(self, x_request_id, connection, **kwargs):  # noqa: E501
        """Retrieve home page of Controller service  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_home(x_request_id, connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_home_with_http_info(
                x_request_id, connection, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_home_with_http_info(
                x_request_id, connection, **kwargs
            )  # noqa: E501
            return data

    def get_home_with_http_info(
        self, x_request_id, connection, **kwargs
    ):  # noqa: E501
        """Retrieve home page of Controller service  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_home_with_http_info(x_request_id, connection,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["x_request_id", "connection"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_home" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`get_home`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`get_home`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["text/html"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_logs(
        self, x_request_id, connection, offset, **kwargs
    ):  # noqa: E501
        """Get console logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logs(x_request_id, connection, offset,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param int offset: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_logs_with_http_info(
                x_request_id, connection, offset, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_logs_with_http_info(
                x_request_id, connection, offset, **kwargs
            )  # noqa: E501
            return data

    def get_logs_with_http_info(
        self, x_request_id, connection, offset, **kwargs
    ):  # noqa: E501
        """Get console logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logs_with_http_info(x_request_id, connection,
        name, offset, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param int offset: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["x_request_id", "connection", "offset"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logs" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`get_logs`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`get_logs`"
            )  # noqa: E501

        # verify the required parameter 'offset' is set
        if "offset" not in params or params["offset"] is None:
            raise ValueError(
                "Missing the required parameter `offset` when calling "
                "`get_logs`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if "offset" in params:
            query_params.append(("offset", params["offset"]))  # noqa: E501

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/bdc/log",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="str",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_mounts(self, x_request_id, connection, **kwargs):  # noqa: E501
        """Get status of mount(s)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mounts(x_request_id, connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str mount:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_mounts_with_http_info(
                x_request_id, connection, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_mounts_with_http_info(
                x_request_id, connection, **kwargs
            )  # noqa: E501
            return data

    def get_mounts_with_http_info(
        self, x_request_id, connection, **kwargs
    ):  # noqa: E501
        """Get status of mount(s)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mounts_with_http_info(x_request_id, connection,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str mount:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["x_request_id", "connection", "mount"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mounts" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`get_mounts`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`get_mounts`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if "mount" in params:
            query_params.append(("mount", params["mount"]))  # noqa: E501

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/bdc/services/hdfs/mounts",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def refresh_mount(
        self, x_request_id, connection, mount, **kwargs
    ):  # noqa: E501
        """Refresh a mount  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_mount(x_request_id, connection, mount,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str mount: Local path to mount on HDFS (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.refresh_mount_with_http_info(
                x_request_id, connection, mount, **kwargs
            )  # noqa: E501
        else:
            (data) = self.refresh_mount_with_http_info(
                x_request_id, connection, mount, **kwargs
            )  # noqa: E501
            return data

    def refresh_mount_with_http_info(
        self, x_request_id, connection, mount, **kwargs
    ):  # noqa: E501
        """Refresh a mount  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_mount_with_http_info(x_request_id,
        connection, mount, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str mount: Local path to mount on HDFS (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["x_request_id", "connection", "mount"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method refresh_mount" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`refresh_mount`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`refresh_mount`"
            )  # noqa: E501
        # verify the required parameter 'mount' is set
        if "mount" not in params or params["mount"] is None:
            raise ValueError(
                "Missing the required parameter `mount` when calling "
                "`refresh_mount`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if "mount" in params:
            query_params.append(("mount", params["mount"]))  # noqa: E501

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(
            # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/bdc/services/hdfs/mounts/refresh",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def update_password(
        self,
        x_request_id,
        connection,
        service_name,
        service_username,
        data,
        **kwargs,
    ):  # noqa: E501
        """Update the password for the given service and user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_password(x_request_id, connection,
        service_name, service_username, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str service_name: (required)
        :param str service_username: (required)
        :param str data: Password and cluster name in JSON format (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.update_password_with_http_info(
                x_request_id,
                connection,
                service_name,
                service_username,
                data,
                **kwargs,
            )  # noqa: E501
        else:
            (data) = self.update_password_with_http_info(
                x_request_id,
                connection,
                service_name,
                service_username,
                data,
                **kwargs,
            )  # noqa: E501
            return data

    def update_password_with_http_info(
        self,
        x_request_id,
        connection,
        service_name,
        service_username,
        data,
        **kwargs,
    ):  # noqa: E501
        """Update the password for the given service and user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_password_with_http_info(x_request_id,
        connection, service_name, service_username, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_request_id: (required)
        :param str connection: (required)
        :param str service_name: (required)
        :param str service_username: (required)
        :param str data: Password and cluster name in JSON format (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "x_request_id",
            "connection",
            "service_name",
            "service_username",
            "data",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_password" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'x_request_id' is set
        if "x_request_id" not in params or params["x_request_id"] is None:
            raise ValueError(
                "Missing the required parameter `x_request_id` when calling "
                "`update_password`"
            )  # noqa: E501
        # verify the required parameter 'connection' is set
        if "connection" not in params or params["connection"] is None:
            raise ValueError(
                "Missing the required parameter `connection` when calling "
                "`update_password`"
            )  # noqa: E501
        # verify the required parameter 'service_name' is set
        if "service_name" not in params or params["service_name"] is None:
            raise ValueError(
                "Missing the required parameter `service_name` when calling "
                "`update_password`"
            )  # noqa: E501
        # verify the required parameter 'service_username' is set
        if (
            "service_username" not in params
            or params["service_username"] is None
        ):
            raise ValueError(
                "Missing the required parameter `service_username` when "
                "calling `update_password`"
            )  # noqa: E501
        # verify the required parameter 'data' is set
        if "data" not in params or params["data"] is None:
            raise ValueError(
                "Missing the required parameter `data` when calling "
                "`update_password`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "service_name" in params:
            path_params["serviceName"] = params["service_name"]  # noqa: E501
        if "service_username" in params:
            path_params["serviceUsername"] = params[
                "service_username"
            ]  # noqa: E501

        query_params = []

        header_params = {}
        if "x_request_id" in params:
            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
        if "connection" in params:
            header_params["Connection"] = params["connection"]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if "data" in params:
            body_params = params["data"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(
            # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/passwords/{serviceName}/{serviceUsername}",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def logs_post(self, version, **kwargs):  # noqa: E501
        """Gets logs from Elasticsearch.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logs_post(version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :param LogsRequest body:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.logs_post_with_http_info(
                version, **kwargs
            )  # noqa: E501
        else:
            (data) = self.logs_post_with_http_info(
                version, **kwargs
            )  # noqa: E501
            return data

    def logs_post_with_http_info(self, version, **kwargs):  # noqa: E501
        """Gets logs from Elasticsearch.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logs_post_with_http_info(version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :param LogsRequest body:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["version", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logs_post" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'version' is set
        if "version" not in params or params["version"] is None:
            raise ValueError(
                "Missing the required parameter `version` when calling "
                "`logs_post`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "version" in params:
            path_params["version"] = params["version"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(
            # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v{version}/logs",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def metrics_post(self, version, **kwargs):  # noqa: E501
        """api_vversion_metrics_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.metrics_post(version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :param object body:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.metrics_post_with_http_info(
                version, **kwargs
            )  # noqa: E501
        else:
            (data) = self.metrics_post_with_http_info(
                version, **kwargs
            )  # noqa: E501
            return data

    def metrics_post_with_http_info(self, version, **kwargs):  # noqa: E501
        """api_vversion_metrics_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.metrics_post_with_http_info(version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :param object body:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["version", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method metrics_post" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'version' is set
        if "version" not in params or params["version"] is None:
            raise ValueError(
                "Missing the required parameter `version` when calling "
                "`metrics_post`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "version" in params:
            path_params["version"] = params["version"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]

        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v{version}/metrics",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def api_v1_metrics_post(self, **kwargs):  # noqa: E501
        """api_v1_metrics_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v1_metrics_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.api_v1_metrics_post_with_http_info(
                **kwargs
            )  # noqa: E501
        else:
            (data) = self.api_v1_metrics_post_with_http_info(
                **kwargs
            )  # noqa: E501
            return data

    def api_v1_metrics_post_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_metrics_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> result = thread.get()

        :param async_req bool
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["db", "query"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_metrics_post" % key
                )
            params[key] = val
        del params["kwargs"]

        if "db" not in params or params["db"] is None:
            raise ValueError(
                "Missing the required parameter `db` when calling "
                "`run_ml_app`"
            )  # noqa: E501

        if "query" not in params or params["query"] is None:
            raise ValueError(
                "Missing the required parameter `query` when calling "
                "`run_ml_app`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        body_params = {"db": params["db"], "query": params["query"]}
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["basic"]  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/metrics",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def api_v1_logs_post(self, body, **kwargs):  # noqa: E501
        """Gets logs from Elasticsearch.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v1_logs_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogsRequest body: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.api_v1_logs_post_with_http_info(
                body, **kwargs
            )  # noqa: E501
        else:
            (data) = self.api_v1_logs_post_with_http_info(
                body, **kwargs
            )  # noqa:
            # E501
            return data

    def api_v1_logs_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Gets logs from Elasticsearch.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v1_logs_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogsRequest body: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_logs_post" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'body' is set
        if "body" not in params or params["body"] is None:
            raise ValueError(
                "Missing the required parameter `body` when calling "
                "`api_v1_logs_post`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(
            # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v1/logs",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def resource_spec_get(self, resource_type, **kwargs):  # noqa: E501
        """resource_spec_get  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resource_spec_get(resource_type, async_req=True)
        >>> result = thread.get()
        :param async_req bool
        :param str resource_type: (required)
        :return: string
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.resource_spec_get_with_http_info(
                resource_type, **kwargs
            )  # noqa: E501
        else:
            (data) = self.resource_spec_get_with_http_info(
                resource_type, **kwargs
            )  # noqa:
            #  E501
            return data

    def resource_spec_get_with_http_info(
        self, resource_type, **kwargs
    ):  # noqa: E501
        """resource_spec_get  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resource_spec_get_with_http_info(resource_type,
        async_req=True)
        >>> result = thread.get()
        :param async_req bool
        :param str resource_type: (required)
        :return: string
                 If the method is called asynchronously,
                 returns the request thread.
        """
        all_params = ["resource_type"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")
        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resource_spec_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'resource_type' is set
        if "resource_type" not in params or params["resource_type"] is None:
            raise ValueError(
                "Missing the required parameter `resource_type` when calling "
                "`resource_type_get`"
            )  # noqa: E501
        collection_formats = {}
        path_params = {}
        if "resource_type" in params:
            path_params["resourceType"] = params["resource_type"]  # noqa: E501
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501
        # Authentication setting
        auth_settings = []  # noqa: E501
        return self.api_client.call_api(
            "/api/v1/arc/resource-types/{resourceType}/spec",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def resource_crd_get(self, resource_type, **kwargs):  # noqa: E501
        """resource_crd_get  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resource_crd_get(resource_type, async_req=True)
        >>> result = thread.get()
        :param async_req bool
        :param str resource_type: (required)
        :return: string
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.resource_crd_get_with_http_info(
                resource_type, **kwargs
            )  # noqa: E501
        else:
            (data) = self.resource_crd_get_with_http_info(
                resource_type, **kwargs
            )  # noqa:
            # E501
            return data

    def resource_crd_get_with_http_info(
        self, resource_type, **kwargs
    ):  # noqa: E501
        """resource_crd_get  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resource_crd_get_with_http_info(resource_type,
        async_req=True)
        >>> result = thread.get()
        :param async_req bool
        :param str resource_type: (required)
        :return: string
                 If the method is called asynchronously,
                 returns the request thread.
        """
        all_params = ["resource_type"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")
        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resource_crd_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'resource_type' is set
        if "resource_type" not in params or params["resource_type"] is None:
            raise ValueError(
                "Missing the required parameter `resource_type` when calling "
                "`resource_type_get`"
            )  # noqa: E501
        collection_formats = {}
        path_params = {}
        if "resource_type" in params:
            path_params["resourceType"] = params["resource_type"]  # noqa: E501
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501
        # Authentication setting
        auth_settings = []  # noqa: E501
        return self.api_client.call_api(
            "/api/v1/arc/resource-types/{resourceType}/crd",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def resource_types_get(self, **kwargs):  # noqa: E501
        """resource_types_get  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resource_types_get(async_req=True)
        >>> result = thread.get()
        :param async_req bool
        :return: list[string]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.resource_types_get_with_http_info(
                **kwargs
            )  # noqa: E501
        else:
            (data) = self.resource_types_get_with_http_info(
                **kwargs
            )  # noqa: E501
            return data

    def resource_types_get_with_http_info(self, **kwargs):  # noqa: E501
        """resource_types_get  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resource_types_get_with_http_info(async_req=True)
        >>> result = thread.get()
        :param async_req bool
        :return: list[string]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")
        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resource_types_get" % key
                )
            params[key] = val
        del params["kwargs"]
        collection_formats = {}
        path_params = {}
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501
        # Authentication setting
        auth_settings = []  # noqa: E501
        return self.api_client.call_api(
            "/api/v1/arc/resource-types",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def signing_certificate_public_key_get(
        self, version, **kwargs
    ):  # noqa: E501
        """Gets the public key of the usage log signing certificate.  # noqa:
        E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.signing_certificate_public_key_get(version,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.signing_certificate_public_key_get_with_http_info(
                version, **kwargs
            )  # noqa: E501
        else:
            (data) = self.signing_certificate_public_key_get_with_http_info(
                version, **kwargs
            )  # noqa: E501
            return data

    def signing_certificate_public_key_get_with_http_info(
        self, version, **kwargs
    ):  # noqa:
        #  E501
        """Gets the public key of the usage log signing certificate.  # noqa:
        E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.signing_certificate_public_key_get_with_http_info(
        version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["version"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method signing_certificate_public_key_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'version' is set
        if "version" not in params or params["version"] is None:
            raise ValueError(
                "Missing the required parameter `version` when calling "
                "`api_vversion_arc_signing_certificate_public_key_get`"
            )  #
            # noqa: E501

        collection_formats = {}

        path_params = {}
        if "version" in params:
            path_params["version"] = params["version"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["text/plain", "application/json", "text/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v{version}/arc/signing-certificate/public-key",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="str",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def export_file_path_get(self, file_path, version, **kwargs):  # noqa: E501
        """Downloads the file content.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_file_path_get(file_path, version,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_path: The file path to be downloaded. (required)
        :param str version: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.export_file_path_get_with_http_info(
                file_path, version, **kwargs
            )  #
            # noqa: E501
        else:
            (data) = self.export_file_path_get_with_http_info(
                file_path, version, **kwargs
            )  #
            # noqa: E501
            return data

    def export_file_path_get_with_http_info(
        self, file_path, version, **kwargs
    ):  # noqa: E501
        """Downloads the file content.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_file_path_get_with_http_info(file_path,
        version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_path: The file path to be downloaded. (required)
        :param str version: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["file_path", "version"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_file_path_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'file_path' is set
        if "file_path" not in params or params["file_path"] is None:
            raise ValueError(
                "Missing the required parameter `file_path` when calling "
                "`export_file_path_get`"
            )  # noqa: E501
        # verify the required parameter 'version' is set
        if "version" not in params or params["version"] is None:
            raise ValueError(
                "Missing the required parameter `version` when calling "
                "`export_file_path_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "file_path" in params:
            path_params["filePath"] = params["file_path"]  # noqa: E501
        if "version" in params:
            path_params["version"] = params["version"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["text/plain", "application/json", "text/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v{version}/export/{filePath}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="str",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def deleted_resources_get(
        self, start_date, version, **kwargs
    ):  # noqa: E501
        """Gets resources deleted since the start date.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deleted_resources_get(start_date, version,
        async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start_date: The start date of time range within which
        the resources were deleted. (required)
        :param str version: (required)
        :return: list[CustomResourceDeletion]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.deleted_resources_get_with_http_info(
                start_date, version, **kwargs
            )  #
            # noqa: E501
        else:
            (data) = self.deleted_resources_get_with_http_info(
                start_date, version, **kwargs
            )  # noqa: E501
            return data

    def deleted_resources_get_with_http_info(
        self, start_date, version, **kwargs
    ):  # noqa: E501
        """Gets resources deleted since the start date.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deleted_resources_get_with_http_info(start_date, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start_date: The start date of time range within which the resources were deleted. (required)
        :param str version: (required)
        :return: list[CustomResourceDeletion]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["start_date", "version"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deleted_resources_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'start_date' is set
        if "start_date" not in params or params["start_date"] is None:
            raise ValueError(
                "Missing the required parameter `start_date` when calling `deleted_resources_get`"
            )  # noqa: E501
        # verify the required parameter 'version' is set
        if "version" not in params or params["version"] is None:
            raise ValueError(
                "Missing the required parameter `version` when calling `deleted_resources_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "version" in params:
            path_params["version"] = params["version"]  # noqa: E501

        query_params = []
        if "start_date" in params:
            query_params.append(
                ("startDate", params["start_date"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["text/plain", "application/json", "text/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/api/v{version}/arc/deleted-resources",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[CustomResourceDeletion]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )


##############################################################################
##############################################################################
##############################################################################


# ------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# ------------------------------------------------------------------------------

"""
Read and modify configuration settings related to the CLI, this to include:

1. Controller API

No description provided (generated by Swagger Codegen
https://github.com/swagger-api/swagger-codegen)  # noqa: E501

OpenAPI spec version: v1.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git

2. CLI global configurations
"""


from six.moves import http_client as httplib

# from .__version__ import __title__, __version__, __server_version__
from azext_arcdata.core.util import singleton
from base64 import b64encode

import re
import sys
import os
import multiprocessing


@singleton
class ConfigurationOld(object):
    """
    The CLI Configuration singleton.
    """

    CLI_NAME = "azdata"
    """
    The name of the CLI.
    """

    LICENSE = "https://aka.ms/eula-azdata-en"
    """
    The Azdata CLI license.
    """

    CLI_ENV_VAR_PREFIX = CLI_NAME
    """
    Prefix all environmental variables with name.
    """

    EXTENSIONS_PREFIX = "{name}ext_".format(name=CLI_NAME)
    """
    Prefix for all extension modules. Example: `azdata_myextension`.
    """

    CLI_CONFIG_DIR = os.getenv(
        "{}_CONFIG_DIR".format(CLI_ENV_VAR_PREFIX.upper()), None
    ) or os.path.expanduser(os.path.join("~", ".{}".format(CLI_NAME)))
    """
    The CLI framework's configuration directory. Defaults to USER HOME.    
    """

    BOOLEAN_STATES = {
        "1": True,
        "yes": True,
        "true": True,
        "on": True,
        "0": False,
        "no": False,
        "false": False,
        "off": False,
        None: False,
        "None": False,
    }
    """
    Mapping of different common logical prepositions to boolean equivalent.
    """

    def __init__(self):
        """
        Configuration runtime constructor.
        """

        # -- extension location --
        self.extension_house = None

        # -- Default Base url --
        self.host = None

        self.user_agent = "{0}/{1}/python".format(
            "azdata-cli-core", self.version
        )

        # -- Temp file folder for downloading files --
        self.temp_folder_path = None

        # -- Log HTTP Rules: Skip logging of header|request|response --
        self._log_api_blacklist = {  # defaults (NOTE: Add more when needed)
            "headers": [
                {
                    "url": re.compile(".*?"),  # All skip these header value
                    "values": ["Authorization"],
                }
            ],
            "request": [
                re.compile(".*/api/v.[0-9]*/hybrid/sql/create$"),
                re.compile("/dusky/databases"),
                re.compile("/dusky/databases/[^/]+/[^/]+"),
                re.compile("/dusky/databases/[^/]+/[^/]+/users/?"),
            ],
            "response": [
                re.compile(
                    ".*/api/v.[0-9]*/token$"
                ),  # skip `host/api/v*/token`
                re.compile("/dusky/databases/[^/]+/[^/]+/password"),
                re.compile("/dusky/databases/[^/]+/[^/]+/users/?"),
                re.compile(".*/api/v.[0-9]*/logs$"),
                re.compile(".*/api/v.[0-9]*/arc/usages$"),
                re.compile(".*/api/v.[0-9]*/registration/listResources/test$"),
            ],
        }

        self._interactive = True if sys.stdin.isatty() else False

        # --- Authentication Settings ---

        # dict to store API key(s)
        self.api_key = {}
        # dict to store API prefix (e.g. Bearer)
        self.api_key_prefix = {}

        # Username for HTTP basic authentication
        self.username = ""
        # Password for HTTP basic authentication
        self.password = ""

        # Debug switch
        self.debug = False
        self.verbose = False

        # --- SSL/TLS verification ---
        self.verify_ssl = False
        self.ssl_ca_cert = None
        self.cert_file = None
        self.key_file = None
        self.assert_hostname = None

        # -- Proxy URL --
        self.proxy = None

        # -- Active controller context during this session --
        self.__context = None

        # urllib3 connection pool's maximum number of connections saved
        # per pool. urllib3 uses 1 connection as default value, but this is
        # not the best value when you are making a lot of possibly parallel
        # requests to the same host, which is often the case here.
        # cpu_count * 5 is used as default value to increase performance.
        self.connection_pool_maxsize = multiprocessing.cpu_count() * 5

        # Safe chars for path_param
        self.safe_chars_for_path_param = ""

    @property
    def version(self):
        """
        Gets the client CLI version.
        """
        return __version__

    @property
    def server_version(self):
        """
        Gets the current SQL Server version at the time of releasing this
        version of the CLI.
        """
        return __server_version__

    @property
    def build(self):
        """
        Gets the AzureDevOps pipeline run number from env-var defined in the
        `azure-pipeline.yaml` and set during build run time. If not set, it will
        be ignored. Format: BUILDNUMER.REV:BRANCH
        """
        from importlib import import_module

        build = None

        try:
            mod = import_module("azdata.cli.core.__build__")
            build = mod.PIPELINE_RUN_NUMBER
        except (ImportError, Exception):
            pass

        return build

    @property
    def log_api_blacklist(self):
        """
        Gets the map of APIs to hide respective logging attributes.
        """
        return self._log_api_blacklist

    @property
    def extension_house(self):
        """
        Gets the location for where to store and manage extension.
        """
        # if empty attempt to use env-var value otherwise default
        if not self._extension_house:
            env = os.getenv(
                "{}_EXTENSION_DIR".format(self.CLI_ENV_VAR_PREFIX.upper())
            )
            self.extension_house = env or os.path.join(
                self.CLI_CONFIG_DIR, "extensions"
            )

        return self._extension_house

    @extension_house.setter
    def extension_house(self, extension_house):
        """
        The CLI framework's command extension directory. Default is under the
        `CLI_CONFIG_DIR/extensions` location.
        """
        self._extension_house = extension_house

    @property
    def interactive(self):
        """
        Get the state on whether to prompt the user interactively if they are
        in an interactive terminal.
        """
        return self._interactive

    @interactive.setter
    def interactive(self, interactive):
        if isinstance(interactive, str):
            interactive = self.BOOLEAN_STATES[interactive.lower()]

        self._interactive = interactive

    @property
    def verify_ssl(self):
        """
        Get the state on whether to skip or verify SSL certificates.
        """
        return self.__verify_ssl

    @verify_ssl.setter
    def verify_ssl(self, verify_ssl):
        """
        Set to skip or verify SSL certificate when calling API from any https
        servers. Default is `False` for the immediate to suppress urllib3
        warnings.

        @TODO: Swap the default to `True` before shipping.
        """
        if isinstance(verify_ssl, str):
            verify_ssl = self.BOOLEAN_STATES[verify_ssl.lower()]

        self.__verify_ssl = verify_ssl or False

        if not self.verify_ssl:
            import urllib3

            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    @property
    def ssl_ca_cert(self):
        """
        Get optional certificate file location to verify the peer.
        """
        return self.__ssl_ca_cert

    @ssl_ca_cert.setter
    def ssl_ca_cert(self, ssl_ca_cert):
        """
        Set to customize the certificate file to verify the peer. SSL client
        certificate default, if String, path to ssl client cert file (.pem).
        """
        self.__ssl_ca_cert = ssl_ca_cert

    @property
    def cert_file(self):
        """
        Gets the optional client certificate file location.
        """
        return self.__cert_file

    @cert_file.setter
    def cert_file(self, cert_file):
        """
        Sets the optional client certificate file location.
        """
        self.__cert_file = cert_file

    @property
    def key_file(self):
        """
        Get the optional client key file location.
        """
        return self.__key_file

    @key_file.setter
    def key_file(self, key_file):
        """
        Set the optional client key file location.
        """
        self.__key_file = key_file

    @property
    def assert_hostname(self):
        """
        Gets the optional SSL hostname verification state.
        """
        return self.__assert_hostname

    @assert_hostname.setter
    def assert_hostname(self, assert_hostname):
        """
        Setter to enable/disable the optional SSL hostname verification.
        """
        if isinstance(assert_hostname, str):
            assert_hostname = self.BOOLEAN_STATES[assert_hostname.lower()]

        self.__assert_hostname = assert_hostname or None

    @property
    def proxy_url(self):
        """
        Gets the optional Proxy URL.
        """
        return self.__proxy_url

    @proxy_url.setter
    def proxy_url(self, proxy_url):
        """
        Sets the optional Proxy URL.
        """
        self.__proxy_url = proxy_url

    @property
    def host(self):
        """
        Gets the controller-plane host endpoint.
        """
        return os.environ.get("TEST_PORT_ENDPOINT")

    @host.setter
    def host(self, host):
        """
        Sets the controller-plan host endpoint.
        """
        self.__host = host

    @property
    def user_agent(self):
        """
        Gets the user-agent.
        """
        return self.__user_agent

    @user_agent.setter
    def user_agent(self, user_agent):
        """
        Sets the the user-agent.
        """
        self.__user_agent = user_agent

    @property
    def api_key_prefix(self):
        """
        Gets the api_key_prefix (ex. Bearer).
        """
        return self.__api_key_prefix

    @api_key_prefix.setter
    def api_key_prefix(self, value):
        self.__api_key_prefix = value

    @property
    def verbose(self):
        """
        Gets the verbose status.
        """
        return self.__verbose

    @verbose.setter
    def verbose(self, value):
        """
        Sets the verbose status.

        :param value: The verbose status, True or False.
        :type: bool
        """
        self.__verbose = value

    @property
    def debug(self):
        """
        Gets the debug status.
        """
        return self.__debug

    @debug.setter
    def debug(self, value):
        """
        Sets the debug status.

        :param value: The debug status, True or False.
        :type: bool
        """
        self.__debug = value

    @property
    def context(self):
        """
        Gets the active-context in this session.
        """
        return self.__context

    @context.setter
    def context(self, context):
        """
        Sets this context in memory to run as the active-context for this
        session. This will not be persisted.
        """
        self.__context = context

    def get_api_key_with_prefix(self, identifier):
        """Gets API key (with prefix if set).

        :param identifier: The identifier of apiKey.
        :return: The token for api key authentication.
        """
        if self.api_key.get(identifier) and self.api_key_prefix.get(identifier):
            return (
                self.api_key_prefix[identifier] + " " + self.api_key[identifier]
            )  # noqa: E501
        elif self.api_key.get(identifier):
            return self.api_key[identifier]

    def get_basic_auth_token(self, strip_prefix=False):
        """Gets HTTP basic authentication header (string).

        :return: The token for basic HTTP authentication.
        """

        encoding = b64encode(
            (self.username + ":" + self.password).encode("utf-8")
        )
        token = "Basic " + str(encoding, "utf-8")

        # remove "Basic" from token format "Basic b64-encoded=="
        if strip_prefix:
            token = token.split()[1]

        return token

    def auth_settings(self):
        return {}
